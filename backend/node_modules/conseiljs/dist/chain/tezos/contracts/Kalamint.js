"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KalamintHelper = void 0;
const TezosNodeReader_1 = require("../TezosNodeReader");
const TezosNodeWriter_1 = require("../TezosNodeWriter");
const TezosTypes = __importStar(require("../../../types/tezos/TezosChainTypes"));
const TezosContractUtils_1 = require("./TezosContractUtils");
const ConseilQueryBuilder_1 = require("../../../reporting/ConseilQueryBuilder");
const TezosMessageUtil_1 = require("../TezosMessageUtil");
const QueryTypes_1 = require("../../../types/conseil/QueryTypes");
const TezosConseilClient_1 = require("../../../reporting/tezos/TezosConseilClient");
const jsonpath_plus_1 = require("jsonpath-plus");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const FetchSelector_1 = __importDefault(require("../../../utils/FetchSelector"));
const fetch = FetchSelector_1.default.fetch;
var KalamintHelper;
(function (KalamintHelper) {
    KalamintHelper.artHouseAddress = "KT1EpGgjQs73QfFJs9z7m1Mxm5MTnpC2tqse";
    KalamintHelper.auctionFactoryAddress = "KT1MiSxkVDFDrAMYCZZXdBEkNrf1NWzfnnRR";
    KalamintHelper.ledgerMapId = 857;
    KalamintHelper.metadataMapId = 860;
    KalamintHelper.tokenMapId = 861;
    function getStorage(server, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const storageResult = yield TezosNodeReader_1.TezosNodeReader.getContractStorage(server, address);
            const auctionsArray = (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[3]', json: storageResult })[0];
            let auctions = {};
            for (const elt of auctionsArray) {
                auctions[elt.args[0].int] = elt.args[1].string;
            }
            return {
                administrator: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[0].args[0].string', json: storageResult })[0],
                allCollections: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[0].args[1].int', json: storageResult })[0],
                allTokens: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[1].int', json: storageResult })[0],
                auctionsFactory: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[2].string', json: storageResult })[0],
                auctions: auctions,
                biddingFee: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[1].args[0].int', json: storageResult })[0],
                collections: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[1].args[1].int', json: storageResult })[0],
                idMaxIncrement: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[2].int', json: storageResult })[0],
                ipfsRegistry: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[3].string', json: storageResult })[0],
                ledger: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[4].int', json: storageResult })[0],
                maxEditions: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[0].args[0].int', json: storageResult })[0],
                maxRoyalty: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[0].args[1].int', json: storageResult })[0],
                metadata: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[1].int', json: storageResult })[0],
                operators: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[3].int', json: storageResult })[0],
                paused: JSON.parse((0, jsonpath_plus_1.JSONPath)({ path: '$.args[2].args[0].prim', json: storageResult })[0].toLowerCase()),
                tokenMetadata: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[2].args[1].int', json: storageResult })[0],
                tokens: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[2].args[2].int', json: storageResult })[0],
                tradingFee: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[3].int', json: storageResult })[0],
                tradingFeeCollector: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[4].int', json: storageResult })[0],
                x: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[5].int', json: storageResult })[0]
            };
        });
    }
    KalamintHelper.getStorage = getStorage;
    function bid(server, address, signer, keystore, bid, fee, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'bid';
            const parameters = `${bid.tokenId}`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, bid.amount, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    KalamintHelper.bid = bid;
    function buy(server, address, signer, keystore, buy, fee, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'buy';
            const parameters = `{"int": "${buy.tokenId}"}`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, buy.amount, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Micheline);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    KalamintHelper.buy = buy;
    function getArtworks(ledgerMapId, tokenMapId, metadataMapId, address, serverInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const operationsQuery = makeOperationsQuery(address, ledgerMapId);
            const operationsResult = yield TezosConseilClient_1.TezosConseilClient.getTezosEntityData(serverInfo, serverInfo.network, 'big_map_contents', operationsQuery);
            const operationGroupIds = operationsResult.map((r) => r.operation_group_id);
            const operationChunks = chunkArray(operationGroupIds, 30);
            const invocations = {};
            operationsResult.map((row) => invocations[row.key.replace(/.* ([0-9]{1,})/, '$1')] = row.operation_group_id);
            const invocationChunks = chunkArray(Object.entries(invocations).map(([id, operation]) => id), 30);
            const invocationMetadataQueries = operationChunks.map((c) => makeInvocationMetadataQuery(c));
            const invocationMetadata = {};
            const endAuctionOperations = [];
            yield Promise.all(invocationMetadataQueries.map((q) => __awaiter(this, void 0, void 0, function* () {
                const invocationsResult = yield TezosConseilClient_1.TezosConseilClient.getTezosEntityData(serverInfo, serverInfo.network, 'operations', q);
                invocationsResult.map((row) => __awaiter(this, void 0, void 0, function* () {
                    const metadata = yield parseInvocationMetadataResult(row);
                    if (metadata.amount === undefined)
                        endAuctionOperations.push(row.operation_group_hash);
                    invocationMetadata[row.operation_group_hash] = metadata;
                }));
            })));
            const endAuctionChunks = chunkArray(endAuctionOperations, 30);
            const endAuctionQueries = endAuctionChunks.map((c) => makeEndAuctionQuery(c));
            yield Promise.all(endAuctionQueries.map((q) => __awaiter(this, void 0, void 0, function* () {
                const endAuctionResult = yield TezosConseilClient_1.TezosConseilClient.getTezosEntityData(serverInfo, serverInfo.network, 'operations', q);
                endAuctionResult.map((row) => invocationMetadata[row.operation_group_hash].price = parseEndAuctionResult(row));
            })));
            const tokenMetadataQueries = invocationChunks.map((c) => [makeTokenQuery(tokenMapId, c), makeTokenQuery(metadataMapId, c)]);
            const artworks = [];
            yield Promise.all(tokenMetadataQueries.map(([tokenQuery, metadataQuery]) => __awaiter(this, void 0, void 0, function* () {
                const tokenResult = yield TezosConseilClient_1.TezosConseilClient.getTezosEntityData(serverInfo, serverInfo.network, 'big_map_contents', tokenQuery);
                const metadataResult = yield TezosConseilClient_1.TezosConseilClient.getTezosEntityData(serverInfo, serverInfo.network, 'big_map_contents', metadataQuery);
                tokenResult.map((row, i) => {
                    const metadataURI = parseMetadataResult(metadataResult[i]);
                    artworks.push(parseTokenResult(row, invocations, invocationMetadata, metadataURI));
                });
            })));
            return artworks.sort((a, b) => b.acquisition.timestamp.getTime() - a.acquisition.timestamp.getTime());
        });
    }
    KalamintHelper.getArtworks = getArtworks;
    function makeOperationsQuery(address, ledgerMapId) {
        let operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(operationsQuery, 'key', 'value', 'operation_group_id');
        operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(operationsQuery, 'big_map_id', QueryTypes_1.ConseilOperator.EQ, [ledgerMapId]);
        operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(operationsQuery, 'key', QueryTypes_1.ConseilOperator.STARTSWITH, [
            `Pair 0x${TezosMessageUtil_1.TezosMessageUtils.writeAddress(address)}`,
        ]);
        operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(operationsQuery, 'value', QueryTypes_1.ConseilOperator.EQ, [0], true);
        operationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(operationsQuery, 10000);
        return operationsQuery;
    }
    function makeInvocationMetadataQuery(operations) {
        let invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(invocationsQuery, 'timestamp', 'amount', 'operation_group_hash', 'parameters_entrypoints');
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(invocationsQuery, 'kind', QueryTypes_1.ConseilOperator.EQ, ['transaction']);
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(invocationsQuery, 'status', QueryTypes_1.ConseilOperator.EQ, ['applied']);
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(invocationsQuery, 'internal', QueryTypes_1.ConseilOperator.EQ, ['false']);
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(invocationsQuery, 'operation_group_hash', operations.length > 1 ? QueryTypes_1.ConseilOperator.IN : QueryTypes_1.ConseilOperator.EQ, operations);
        invocationsQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(invocationsQuery, operations.length);
        return invocationsQuery;
    }
    function parseInvocationMetadataResult(row) {
        return __awaiter(this, void 0, void 0, function* () {
            let entryPoint = row.parameters_entrypoints;
            let price;
            if (entryPoint === 'buy') {
                price = new bignumber_js_1.default(parseInt(row.amount));
            }
            else if (entryPoint === 'resolve_auction') {
                price = undefined;
            }
            else
                price = new bignumber_js_1.default(0);
            return {
                entryPoint: entryPoint,
                amount: price,
                timestamp: new Date(row.timestamp)
            };
        });
    }
    function makeEndAuctionQuery(operations) {
        let endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(endAuctionQuery, 'amount', 'operation_group_hash');
        endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(endAuctionQuery, 'internal', QueryTypes_1.ConseilOperator.EQ, ['true']);
        endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(endAuctionQuery, 'parameters_entrypoints', QueryTypes_1.ConseilOperator.EQ, ['end_auction']);
        endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(endAuctionQuery, 'operation_group_hash', operations.length > 1 ? QueryTypes_1.ConseilOperator.IN : QueryTypes_1.ConseilOperator.EQ, operations);
        endAuctionQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(endAuctionQuery, operations.length);
        return endAuctionQuery;
    }
    function parseEndAuctionResult(row) {
        return new bignumber_js_1.default(row.amount);
    }
    function makeTokenQuery(tokenMapId, tokenIds) {
        let tokensQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        tokensQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(tokensQuery, 'key', 'value', 'operation_group_id');
        tokensQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(tokensQuery, 'big_map_id', QueryTypes_1.ConseilOperator.EQ, [tokenMapId]);
        tokensQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(tokensQuery, 'key', tokenIds.length > 1 ? QueryTypes_1.ConseilOperator.IN : QueryTypes_1.ConseilOperator.EQ, tokenIds);
        tokensQuery = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(tokensQuery, tokenIds.length);
        return tokensQuery;
    }
    function parseMetadataResult(row) {
        const metadataURIBytes = row.value.toString().replace(/.*? 0x([a-zA-Z0-9]*).*/, '$1');
        return TezosMessageUtil_1.TezosMessageUtils.readString(metadataURIBytes).slice(3);
    }
    function parseTokenResult(row, invocations, invocationsMetadata, metadataURI) {
        let tokenId = parseInt(row.key);
        let invocationOperation = invocations[tokenId];
        let invocationMetadata = invocationsMetadata[invocationOperation];
        return {
            tokenId: parseInt(row.key),
            name: row.value.toString().replace(/.* \"name\" "(.*?)" .*/, '$1'),
            description: undefined,
            acquisition: invocationMetadata,
            collection: {
                collectionName: row.value.toString().replace(/.* "collection_name" "(.*?)" .*/, '$1'),
                creatorName: row.value.toString().replace(/.* "creator_name" "(.*?)" .*/, '$1'),
                editions: parseInt(row.value.toString().replace(/.* ([0-9]*?) }/, '$1')),
                editionNumber: parseInt(row.value.toString().replace(/.* ([0-9]*?) ; [0-9]* }/, '$1'))
            },
            currentPrice: new bignumber_js_1.default(parseInt(row.value.toString().replace(/.* } ; [0-9]+ ; ([0-9]*?) .*/, '$1'))),
            onSale: row.value.toString().replace(/.* "ipfs:.*" ; .*? ; \b(False|True)\b .*/, '$1').toLowerCase().startsWith('t'),
            onAuction: row.value.toString().replace(/.* "ipfs:.*" ; .*? ; \b(False|True)\b ; \b(False|True)\b.*/, '$2').toLowerCase().startsWith('t'),
            metadataURI: metadataURI,
            artifactURI: row.value.toString().replace(/.* \"ipfs:\\\/\\\/([a-zA-Z0-9]*?)" .*/, '$1')
        };
    }
    function getTokenTransactions(artHouseAddress, auctionFactoryAddress, address, serverInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const direct = makeDirectTxQuery(address, [artHouseAddress, auctionFactoryAddress]);
            const indirect = makeIndirectTxQuery(address, artHouseAddress);
            let transactions = [];
            yield Promise.all([direct, indirect].map((q) => __awaiter(this, void 0, void 0, function* () {
                const transactionsResult = yield TezosConseilClient_1.TezosConseilClient.getOperations(serverInfo, serverInfo.network, q);
                transactionsResult.map((row) => transactions.push(parseTransactionsQuery(row)));
            })));
            return transactions.sort((a, b) => a.invocation.timestamp.getTime() - b.invocation.timestamp.getTime());
        });
    }
    KalamintHelper.getTokenTransactions = getTokenTransactions;
    function makeDirectTxQuery(address, contracts) {
        let direct = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(direct, 'timestamp', 'source', 'destination', 'amount', 'fee', 'operation_group_hash', 'parameters_entrypoints');
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(direct, 'kind', QueryTypes_1.ConseilOperator.EQ, ['transaction'], false);
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(direct, 'status', QueryTypes_1.ConseilOperator.EQ, ['applied'], false);
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(direct, 'destination', QueryTypes_1.ConseilOperator.IN, contracts, false);
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(direct, 'source', QueryTypes_1.ConseilOperator.EQ, [address], false);
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.addOrdering(direct, 'timestamp', QueryTypes_1.ConseilSortDirection.DESC);
        direct = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(direct, 5000);
        return direct;
    }
    function makeIndirectTxQuery(address, contractAddress) {
        let indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.blankQuery();
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addFields(indirect, 'timestamp', 'source', 'destination', 'amount', 'fee', 'operation_group_hash', 'parameters_entrypoints');
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(indirect, 'kind', QueryTypes_1.ConseilOperator.EQ, ['transaction'], false);
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(indirect, 'status', QueryTypes_1.ConseilOperator.EQ, ['applied'], false);
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(indirect, 'destination', QueryTypes_1.ConseilOperator.EQ, [contractAddress], false);
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addPredicate(indirect, 'parameters', QueryTypes_1.ConseilOperator.LIKE, [address], false);
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.addOrdering(indirect, 'timestamp', QueryTypes_1.ConseilSortDirection.DESC);
        indirect = ConseilQueryBuilder_1.ConseilQueryBuilder.setLimit(indirect, 5000);
        return indirect;
    }
    function parseTransactionsQuery(row) {
        let invocationMetadata = {
            entryPoint: row.parameters_entrypoints,
            amount: new bignumber_js_1.default(row.amount),
            timestamp: new Date(row.timestamp)
        };
        return {
            source: row.source,
            destination: row.destination,
            invocation: invocationMetadata,
            operationGroupHash: row.operation_group_hash,
            fee: new bignumber_js_1.default(row.fee)
        };
    }
    function getArtworkDescription(artwork) {
        return __awaiter(this, void 0, void 0, function* () {
            const metadata = yield fetch(`https://cloudflare-ipfs.com/ipfs/${artwork.metadataURI}`, { cache: 'no-store' });
            const metadataJSON = yield metadata.json();
            artwork.description = metadataJSON.description;
            return artwork;
        });
    }
    KalamintHelper.getArtworkDescription = getArtworkDescription;
    function chunkArray(arr, len) {
        const chunks = [];
        const n = arr.length;
        let i = 0;
        while (i < n) {
            chunks.push(arr.slice(i, (i += len)));
        }
        return chunks;
    }
})(KalamintHelper = exports.KalamintHelper || (exports.KalamintHelper = {}));
//# sourceMappingURL=Kalamint.js.map