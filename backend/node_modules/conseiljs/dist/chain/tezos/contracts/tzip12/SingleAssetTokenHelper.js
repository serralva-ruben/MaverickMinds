"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleAssetTokenHelper = void 0;
const jsonpath_plus_1 = require("jsonpath-plus");
const TezosMessageUtil_1 = require("../../TezosMessageUtil");
const TezosNodeReader_1 = require("../../TezosNodeReader");
const TezosNodeWriter_1 = require("../../TezosNodeWriter");
const TezosTypes = __importStar(require("../../../../types/tezos/TezosChainTypes"));
const TezosContractUtils_1 = require("../TezosContractUtils");
const TezosConstants_1 = require("../../../../types/tezos/TezosConstants");
var SingleAssetTokenHelper;
(function (SingleAssetTokenHelper) {
    function verifyDestination(server, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return TezosContractUtils_1.TezosContractUtils.verifyDestination(server, address, '17aab0975df6139f4ff29be76a67f348');
        });
    }
    SingleAssetTokenHelper.verifyDestination = verifyDestination;
    function verifyScript(script) {
        return TezosContractUtils_1.TezosContractUtils.verifyScript(script, '000');
    }
    SingleAssetTokenHelper.verifyScript = verifyScript;
    function deployContract(server, signer, keystore, fee, administrator, metadataUrl, pause = true, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = `parameter (or (or (pair %balance_of (list %requests (pair (address %owner) (nat %token_id))) (contract %callback (list (pair (pair %request (address %owner) (nat %token_id)) (nat %balance))))) (or (pair %mint (pair (address %address) (nat %amount)) (pair (map %metadata string bytes) (nat %token_id))) (address %set_administrator))) (or (or (pair %set_metadata (string %k) (bytes %v)) (bool %set_pause)) (or (list %transfer (pair (address %from_) (list %txs (pair (address %to_) (pair (nat %token_id) (nat %amount)))))) (list %update_operators (or (pair %add_operator (address %owner) (pair (address %operator) (nat %token_id))) (pair %remove_operator (address %owner) (pair (address %operator) (nat %token_id)))))))); 
        storage (pair (pair (pair (address %administrator) (nat %all_tokens)) (pair (big_map %ledger address nat) (big_map %metadata string bytes))) (pair (pair (big_map %operators (pair (address %owner) (pair (address %operator) (nat %token_id))) unit) (bool %paused)) (pair (big_map %token_metadata nat (pair (nat %token_id) (map %token_info string bytes))) (big_map %total_supply nat nat)))); 
        code { CAST (pair (or (or (pair (list (pair address nat)) (contract (list (pair (pair address nat) nat)))) (or (pair (pair address nat) (pair (map string bytes) nat)) address)) (or (or (pair string bytes) bool) (or (list (pair address (list (pair address (pair nat nat))))) (list (or (pair address (pair address nat)) (pair address (pair address nat))))))) (pair (pair (pair address nat) (pair (big_map address nat) (big_map string bytes))) (pair (pair (big_map (pair address (pair address nat)) unit) bool) (pair (big_map nat (pair nat (map string bytes))) (big_map nat nat))))); UNPAIR; IF_LEFT { IF_LEFT { SWAP; DUP; DUG 2; GET 3; CDR; IF { PUSH string "FA2_PAUSED"; FAILWITH; } {}; DUP; CAR; MAP { DUP 3; GET 5; SWAP; DUP; DUG 2; CDR; MEM; IF {} { PUSH string "FA2_TOKEN_UNDEFINED"; FAILWITH; }; DUP 3; CAR; GET 3; SWAP; DUP; DUG 2; CAR; MEM; IF { DUP 3; CAR; GET 3; SWAP; DUP; DUG 2; CAR; GET; IF_SOME { } { PUSH int 430; FAILWITH; }; SWAP; PAIR; } { PUSH nat 0; SWAP; PAIR; }; }; NIL operation; DIG 2; CDR; PUSH mutez 0; DIG 3; TRANSFER_TOKENS; CONS; } { IF_LEFT { SWAP; DUP; DUG 2; CAR; CAR; CAR; SENDER; COMPARE; EQ; IF {} { PUSH string "FA2_NOT_ADMIN"; FAILWITH; }; DUP; GET 4; PUSH nat 0; COMPARE; EQ; IF {} { PUSH string "single-asset: token-id <> 0"; FAILWITH; }; DUP; GET 4; DUP 3; CAR; CAR; CDR; COMPARE; EQ; IF {} { PUSH string "Token-IDs should be consecutive"; FAILWITH; }; SWAP; DUP; DUG 2; UNPAIR; UNPAIR; CAR; DIG 4; CAR; CAR; CDR; DUP; PUSH nat 1; DUP 7; GET 4; ADD; DUP; DUG 2; COMPARE; LE; IF { DROP; } { SWAP; DROP; }; SWAP; PAIR; PAIR; PAIR; DUP; DUG 2; CAR; GET 3; SWAP; DUP; DUG 2; CAR; CAR; MEM; IF { SWAP; UNPAIR; UNPAIR; SWAP; UNPAIR; DUP; DUP 6; CAR; CAR; DUP; DUG 2; GET; IF_SOME {} { PUSH int 541; FAILWITH; }; DUP 7; CAR; CDR; ADD; SOME; SWAP; UPDATE; PAIR; SWAP; PAIR; PAIR; SWAP; } { SWAP; UNPAIR; UNPAIR; SWAP; UNPAIR; DUP 5; CAR; CDR; SOME; DUP 6; CAR; CAR; UPDATE; PAIR; SWAP; PAIR; PAIR; SWAP; }; SWAP; DUP; DUG 2; GET 5; SWAP; DUP; DUG 2; GET 4; MEM; IF { DROP; } { SWAP; DUP; GET 5; DIG 2; DUP; GET 3; SWAP; DUP; DUG 4; GET 4; PAIR; SOME; DUP 4; GET 4; UPDATE; UPDATE 5; DUP; GET 6; DUP 3; CAR; CDR; SOME; DIG 3; GET 4; UPDATE; UPDATE 6; }; } { SWAP; DUP; DUG 2; CAR; CAR; CAR; SENDER; COMPARE; EQ; IF {} { PUSH string "FA2_NOT_ADMIN"; FAILWITH; }; SWAP; UNPAIR; UNPAIR; CDR; DIG 3; PAIR; PAIR; PAIR; }; NIL operation; }; } { IF_LEFT { IF_LEFT { SWAP; DUP; DUG 2; CAR; CAR; CAR; SENDER; COMPARE; EQ; IF {} { PUSH string "FA2_NOT_ADMIN"; FAILWITH; }; SWAP; UNPAIR; UNPAIR; SWAP; UNPAIR; SWAP; DUP 5; CDR; SOME; DIG 5; CAR; UPDATE; SWAP; PAIR; SWAP; PAIR; PAIR; } { SWAP; DUP; DUG 2; CAR; CAR; CAR; SENDER; COMPARE; EQ; IF {} { PUSH string "FA2_NOT_ADMIN"; FAILWITH; }; SWAP; UNPAIR; SWAP; UNPAIR; CAR; DIG 3; SWAP; PAIR; PAIR; SWAP; PAIR; }; } { IF_LEFT { SWAP; DUP; DUG 2; GET 3; CDR; IF { PUSH string "FA2_PAUSED"; FAILWITH; } {}; DUP; ITER { DUP; CDR; ITER { DUP; GET 3; PUSH nat 0; COMPARE; EQ; IF {} { PUSH string "single-asset: token-id <> 0"; FAILWITH; }; DUP 4; CAR; CAR; CAR; SENDER; COMPARE; EQ; IF { PUSH bool True; } { SENDER; DUP 3; CAR; COMPARE; EQ; }; IF { PUSH bool True; } { DUP 4; GET 3; CAR; SWAP; DUP; DUG 2; GET 3; SENDER; DUP 5; CAR; PAIR 3; MEM; }; IF {} { PUSH string "FA2_NOT_OPERATOR"; FAILWITH; }; DUP 4; GET 5; SWAP; DUP; DUG 2; GET 3; MEM; IF {} { PUSH string "FA2_TOKEN_UNDEFINED"; FAILWITH; }; DUP; GET 4; PUSH nat 0; COMPARE; LT; IF { DUP; GET 4; DUP 5; CAR; GET 3; DUP 4; CAR; GET; IF_SOME { } { PUSH int 408; FAILWITH; }; COMPARE; GE; IF {} { PUSH string "FA2_INSUFFICIENT_BALANCE"; FAILWITH; }; DUP 4; UNPAIR; UNPAIR; SWAP; UNPAIR; DUP; DUP 7; CAR; DUP; DUG 2; GET; IF_SOME { DROP; } { PUSH int 412; FAILWITH; }; DUP 6; GET 4; DIG 9; CAR; GET 3; DUP 9; CAR; GET; IF_SOME { } { PUSH int 412; FAILWITH; }; SUB; ISNAT; IF_SOME {} { PUSH int 412; FAILWITH; }; SOME; SWAP; UPDATE; PAIR; SWAP; PAIR; PAIR; DUP; DUG 4; CAR; GET 3; SWAP; DUP; DUG 2; CAR; MEM; IF { DIG 3; UNPAIR; UNPAIR; SWAP; UNPAIR; DUP; DUP 6; CAR; DUP; DUG 2; GET; IF_SOME {} { PUSH int 415; FAILWITH; }; DIG 6; GET 4; ADD; SOME; SWAP; UPDATE; PAIR; SWAP; PAIR; PAIR; DUG 2; } { DIG 3; UNPAIR; UNPAIR; SWAP; UNPAIR; DUP 5; GET 4; SOME; DIG 5; CAR; UPDATE; PAIR; SWAP; PAIR; PAIR; DUG 2; }; } { DROP; }; }; DROP; }; DROP; } { DUP; ITER { IF_LEFT { DUP; CAR; SENDER; COMPARE; EQ; IF { PUSH bool True; } { DUP 3; CAR; CAR; CAR; SENDER; COMPARE; EQ; }; IF {} { PUSH string "FA2_NOT_ADMIN_OR_OPERATOR"; FAILWITH; }; DIG 2; UNPAIR; SWAP; UNPAIR; UNPAIR; PUSH (option unit) (Some Unit); DIG 5; DUP; GET 4; SWAP; DUP; GET 3; SWAP; CAR; PAIR 3; UPDATE; PAIR; PAIR; SWAP; PAIR; SWAP; } { DUP; CAR; SENDER; COMPARE; EQ; IF { PUSH bool True; } { DUP 3; CAR; CAR; CAR; SENDER; COMPARE; EQ; }; IF {} { PUSH string "FA2_NOT_ADMIN_OR_OPERATOR"; FAILWITH; }; DIG 2; UNPAIR; SWAP; UNPAIR; UNPAIR; NONE unit; DIG 5; DUP; GET 4; SWAP; DUP; GET 3; SWAP; CAR; PAIR 3; UPDATE; PAIR; PAIR; SWAP; PAIR; SWAP; }; }; DROP; }; }; NIL operation; }; PAIR; };`;
            const paused = pause ? "True" : "False";
            const storage = `(Pair (Pair (Pair "${administrator}" 0) (Pair {} {Elt ""  0x${Buffer.from(metadataUrl, "utf-8").toString("hex")}})) (Pair (Pair {} ${paused}) (Pair {} {})))`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractOriginationOperation(server, signer, keystore, 0, undefined, fee, freight, gas, contract, storage, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult['operationGroupID']);
        });
    }
    SingleAssetTokenHelper.deployContract = deployContract;
    function getSimpleStorage(server, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const storageResult = yield TezosNodeReader_1.TezosNodeReader.getContractStorage(server, address);
            return {
                administrator: (0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[0].string', json: storageResult })[0],
                tokens: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[0].args[1].int', json: storageResult })[0]),
                ledger: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[1].int', json: storageResult })[0]),
                metadata: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].args[2].int', json: storageResult })[0]),
                paused: ((0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[1].prim', json: storageResult })[0]).toString().toLowerCase().startsWith('t'),
                operators: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[1].args[0].int', json: storageResult })[0]),
                tokenMetadata: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[2].int', json: storageResult })[0]),
                totalSupply: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[3].int', json: storageResult })[0]),
            };
        });
    }
    SingleAssetTokenHelper.getSimpleStorage = getSimpleStorage;
    function getTokenDefinition(server, mapid) {
        return __awaiter(this, void 0, void 0, function* () {
            const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(0, 'nat'), 'hex'));
            const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);
            if (mapResult === undefined) {
                throw new Error(`Map ${mapid} does not contain a record for token 0`);
            }
            const tokenData = {
                tokenid: Number((0, jsonpath_plus_1.JSONPath)({ path: '$.args[0].int', json: mapResult })[0]),
                metadata: {}
            };
            mapResult["args"][1].forEach(item => {
                tokenData.metadata[item["args"][0]["string"]] = Buffer.from(item["args"][1]["bytes"], "hex").toString();
            });
            return tokenData;
        });
    }
    SingleAssetTokenHelper.getTokenDefinition = getTokenDefinition;
    function activate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'set_pause';
            const parameters = 'False';
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.activate = activate;
    function deactivate(server, address, signer, keystore, fee, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'set_pause';
            const parameters = 'True';
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.deactivate = deactivate;
    function changeAdministrator(server, address, signer, keystore, fee, administrator, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'set_administrator';
            const parameters = `"${administrator}"`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.changeAdministrator = changeAdministrator;
    function mint(server, address, signer, keystore, fee, destination, amount, metadata, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'mint';
            const keys = Object.keys(metadata).sort();
            let metaString = "";
            for (let key of keys) {
                if (metaString !== "")
                    metaString += "; ";
                metaString += `Elt "${key}" 0x${Buffer.from(metadata[key], "utf-8").toString("hex")}`;
            }
            const parameters = `(Pair (Pair "${destination}" ${amount}) (Pair {${metaString}} 1))`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.mint = mint;
    function transfer(server, address, signer, keystore, fee, source, transfers, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'transfer';
            const parameters = `{ Pair 0x${TezosMessageUtil_1.TezosMessageUtils.writeAddress(source)} { ${transfers.map(t => '( Pair 0x' + TezosMessageUtil_1.TezosMessageUtils.writeAddress(t.address) + ' ( Pair ' + 0 + ' ' + t.amount + ' ) )').join(' ; ')} } }`;
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson, TezosConstants_1.TezosConstants.HeadBranchOffset, true);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.transfer = transfer;
    function addOperators(server, address, signer, keystore, fee, updateOps, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'update_operators';
            let parameters = "{";
            updateOps.forEach(op => {
                if (parameters !== "{")
                    parameters += "; ";
                parameters += `Left (Pair "${op.owner}" (Pair "${op.operator}" 0))`;
            });
            parameters += "}";
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.addOperators = addOperators;
    function removeOperators(server, address, signer, keystore, fee, updateOps, gas = 800000, freight = 20000) {
        return __awaiter(this, void 0, void 0, function* () {
            const entryPoint = 'update_operators';
            let parameters = "{";
            updateOps.forEach(op => {
                if (parameters !== "{")
                    parameters += "; ";
                parameters += `Right (Pair "${op.owner}" (Pair "${op.operator}" 0))`;
            });
            parameters += "}";
            const nodeResult = yield TezosNodeWriter_1.TezosNodeWriter.sendContractInvocationOperation(server, signer, keystore, address, 0, fee, freight, gas, entryPoint, parameters, TezosTypes.TezosParameterFormat.Michelson);
            return TezosContractUtils_1.TezosContractUtils.clearRPCOperationGroupHash(nodeResult.operationGroupID);
        });
    }
    SingleAssetTokenHelper.removeOperators = removeOperators;
    function getAccountBalance(server, mapid, account, balancePath = '$.int') {
        return __awaiter(this, void 0, void 0, function* () {
            const packedKey = TezosMessageUtil_1.TezosMessageUtils.encodeBigMapKey(Buffer.from(TezosMessageUtil_1.TezosMessageUtils.writePackedData(account, "address"), 'hex'));
            const mapResult = yield TezosNodeReader_1.TezosNodeReader.getValueForBigMapKey(server, mapid, packedKey);
            if (mapResult === undefined) {
                throw new Error(`Map ${mapid} does not contain a record for ${account}`);
            }
            const balance = Number((0, jsonpath_plus_1.JSONPath)({ path: balancePath, json: mapResult })[0]);
            return balance;
        });
    }
    SingleAssetTokenHelper.getAccountBalance = getAccountBalance;
})(SingleAssetTokenHelper = exports.SingleAssetTokenHelper || (exports.SingleAssetTokenHelper = {}));
//# sourceMappingURL=SingleAssetTokenHelper.js.map